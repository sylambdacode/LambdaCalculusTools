true = λx y. x;
false = λx y. y;
and = λa b. a b a;
or = λa b. a a b;
not = λa. a false true;
xor = λa b. a (not b) b;
if-then-else = λc. c;

pair = λx y f. f x y;
fst = λp. p true;
snd = λp. p false;
match-fst-snd = λp. p;

nil = false;
cons = pair;
head = fst;
tail = snd;
isnil = λl. (λa. a (λb c d. false) true) l;
match-nil-cons = λl n c. if-then-else (isnil l)
                        (n)
                        (c);
match-nil-cons-x-xs = λl n c. match-nil-cons l n (l c);
Y = (λu x. x (u u x)) (λu x. x (u u x));
reserve = λl. (Y λself. λl1 l2. match-nil-cons-x-xs l1
            (l2)
            (λx xs. self xs (cons x l2)))
        l nil;
concat = λl1 l2. (Y λself. λrl1 l2. match-nil-cons-x-xs rl1
            (l2)
            (λ x xs. self xs (cons x l2)))
            (reserve l1) l2;

map = Y λself. λf l. match-nil-cons-x-xs l
            nil
            λx xs. cons (f x) (self f xs);

fold = Y λself. λf init l. match-nil-cons-x-xs l
            init
            λx xs. self f (f init x) xs;

foldr-cps = Y λself. λf init l cont. match-nil-cons-x-xs l
            (cont init)
            λx xs. do {
                r <- self f init xs;
                cont (f x r)
            };

zip2 = Y λself. λl1 l2. match-nil-cons-x-xs l1
            nil
            λx xs. cons (pair x (head l2)) (self xs (tail l2));

bit-add-cps = λc m n cont. if-then-else (and m n)
            (cont true c)
            (if-then-else (or (and m (not n)) (and (not m) n))
                        (cont c (not c))
                        (cont false c));

bits-iszero = λa. fold (λx y. and x (not y)) true a;
bits-iszero-cps = λa cont. foldr-cps (λx y. and (not x) y) true a cont;

bits-op = λop a b. map (λp. match-fst-snd p op) (zip2 a b);

bits-and = bits-op and;
bits-xor = bits-op xor;
bits-not = λa. map not a;

bits-add-cps = Y λself. λc m n cont. match-nil-cons-x-xs m
            (cont c nil)
            (λmx mxs. do {
                clow rbitslow <- self c mxs (tail n);
                cbit rbit <- bit-add-cps clow mx (head n);
                cont cbit (cons rbit rbitslow)
            });

bits-zero = λa. map (λx. false) a;

bits-one = λa. match-nil-cons-x-xs a
            ⊥
            (λx xs. (Y λself. λa. match-nil-cons-x-xs a
                (cons true nil)
                (λx xs. cons false (self xs))) xs);

bits-sub-cps = λm n. bits-add-cps true m (bits-not n);

